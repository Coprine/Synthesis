#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <string.h>
#include <math.h>

struct DreamObj
{
    char name[12];
    char mainTrait;
    int organic;
    int artificial;
    int abstract;
    int transmuteTolerant;
    int inspectTolerant;
    int seedTolerant;
};

    // Array containing the objects for each stage
    struct DreamObj objectArray[5];



// List of names for objects of each tendency
char organicNames[7][12] = {"ERROR 1", "Worm", "Fly", "Tree", "Mouse", "Rat", "Wolf"};
char artificialNames[7][12] = {"Plate", "Table", "Shelf", "Chair", "Lamp", "Book", "Clock"};
char abstractNames[7][12] = {"ERROR 2", "Painting", "Television", "Mirror", "Symbol", "Light", "Shadow"};


// Sets name and determines main trait of object
void typeCalibrate(int index)
{

    // Checks for if the object's organic score is the highest
    if(objectArray[index].organic >= objectArray[index].artificial && objectArray[index].organic >= objectArray[index].abstract)
    {
        // Object's trait set to organic
        objectArray[index].mainTrait = *"o";
        // Object's name set to its corresponding manifestation
        strcpy(objectArray[index].name, organicNames[objectArray[index].organic]);

      // Checks if the object's artificial score is the highest
    } else if(objectArray[index].artificial > objectArray[index].organic && objectArray[index].artificial >= objectArray[index].abstract)
    {
        // Object's trait set to artificial
        objectArray[index].mainTrait = *"r";
        // Object's name set to its corresponding manifestation
        strcpy(objectArray[index].name, artificialNames[objectArray[index].artificial]);

      // CHecks if the object's abstract trait is the highest 
    } else {
        // Object's trait set to abstract
        objectArray[index].mainTrait = *"a";
        // Object's name set to its corresponding manifestation
        strcpy(objectArray[index].name, abstractNames[objectArray[index].abstract]);
    }
}

//Calculates an object's tolerances to various actions
void toleranceCalc(int index)
{
  // Will be linked to world later on
  double globalTTolerantMod = 1;
  double globalITolerantMod = 1;
  double globalSTolerantMod = 1;


  int organic = objectArray[index].organic;
  int artificial = objectArray[index].artificial;
  int abstract = objectArray[index].abstract;

  // Sets variable to be transmute tolerance
  // Formula is a percent equal to a random number 0 through 50 plus 16.66 percent for every point the object has in organic, minus 16.6 percent for each point the object has in artificial. It is then modified by the world's transmute tolerance modifier.
  double transmuteTolerantMod = ((rand()%50)*0.01+((double)organic/6)-((double)artificial/12))*globalTTolerantMod;
  objectArray[index].transmuteTolerant = floor(transmuteTolerantMod * 100);

  // Sets variable to be inspect tolerance
  // Formula is a percent equal to a random number 0 through 50 plus 16.66 percent for every point the object has in artificial, minus 16.6 percent for each point the object has in abstract. It is then modified by the world's inspect tolerance modifier.
  double inspectTolerantMod = ((rand()%50)*0.01+((double)artificial/6)-((double)abstract/12))*globalITolerantMod;
  objectArray[index].inspectTolerant = floor(inspectTolerantMod * 100);

  // Sets variable to be seed tolerance
  // Formula is a percent equal to a random number 0 through 50 plus 16.66 percent for every point the object has in abstract, minus 16.6 percent for each point the object has in organic. It is then modified by the world's seed tolerance modifier.
  double seedTolerantMod = ((rand()%50)*0.01+((double)abstract/6)-((double)organic/12))*globalSTolerantMod;
  objectArray[index].seedTolerant = floor(seedTolerantMod * 100);
}


// Creates a new random object
void createObject(int index)
{

    // Sets tendency traits for new object
    int newOrg = rand()%7;
    int newArt = rand()%7;
    int newAbs = rand()%7;

    objectArray[index].organic = newOrg;
    objectArray[index].artificial = newArt;
    objectArray[index].abstract = newAbs;

    
    // TODO: set tolerances, create interfacing, create functions for: transmutate, synthesize, inspect, and seed (may be renamed to "liken")

    // Notes: abstract objects should be obstacles, however they are the only ones which can be synthesized. Transmuting an abstract object has a high chance of scrambling other objects. Abstraction is rare but hard to reverse. When all objects are abstract, the player loses. Objects with more extreme tendencies are harder to transmute to different tendencies. If all objects are of the same tendency and are not abstract, the player may move on. Difficulty may be modified by making transmuting more risky. Each level should be a "world", which has "rules", perhaps its own tendencies of some sort. Liken makes other objects more like the likened object at the risk of the likened object drastically changing. Identifying will vaguely describe and object's tendencies (strongly organic, weakly artificial, moderately abstract). Different items will have difference tolerances which may disallow certain functions on them.



    // Sets name and determines main trait of object
    typeCalibrate(index);
    // Sets object's tolerances
    toleranceCalc(index);
}

// Main function
int main()
{
    // Initialize random number generator
    srand(time(NULL));

    while(1)
    {
        // Populate the main array with functional dream objects
        for(int i = 0; i<5; i++)
        {
            // Calls function to construct relevant DreamObj
            createObject(i);
            // DEBUG TEXT
            printf("Object %d's type is %s.\n It is a %s\n Org: %d\n Art: %d\n Abs: %d\nTransmute Tolerance: %d%%\nInspect Tolerance: %d%%\nSeed Tolerance: %d%%\n", i, &objectArray[i].mainTrait, objectArray[i].name, objectArray[i].organic, objectArray[i].artificial, objectArray[i].abstract, objectArray[i].transmuteTolerant, objectArray[i].inspectTolerant, objectArray[i].seedTolerant);
            // END DEBUG TEXT
        }

        // Awaits user input, but only once. Will need replaced but works for debugging
        scanf("among us");
    }


    return 0;
}
